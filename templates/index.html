<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>HTML5 Ad Validator - Detailed Report</title>

  <!-- PDF Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      text-align: center;
      margin: 20px;
      background: #fafafa;
    }
    .container {
      width: 90%;
      max-width: 1100px;
      margin: auto;
    }
    input, button {
      margin: 10px;
      padding: 8px;
    }
    #results {
      margin-top: 20px;
      text-align: left;
      white-space: pre-wrap;
      background: #fff;
      padding: 20px;
      border-radius: 5px;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    .error { color: red; font-weight: bold; }
    .warning { color: #cc7a00; }
    .success { color: green; }
    .info { color: #000; font-weight: bold; }
    .pass { color: green; }
    .check { color: #005fcc; }
    .fail { color: red; }

    /* Preview Grid */
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(360px, 1fr));
      gap: 30px;
      margin-top: 20px;
    }

    /* Each banner card */
    .preview-card {
      background: #fff;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      text-align: center;
    }

    /* Banner frame */
    .preview-frame {
      background: #e0e0e0;
      padding: 20px;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 200px;
      overflow: hidden;
    }

    /* Thumbnail toggle */
    .thumbnail {
      transform: scale(0.5);
      transform-origin: top center;
    }

    /* Buttons */
    .open-btn {
      margin-top: 10px;
      padding: 6px 14px;
      border: none;
      background: #0077ff;
      color: #fff;
      border-radius: 5px;
      cursor: pointer;
    }
    .open-btn:hover {
      background: #005fcc;
    }
  </style>
</head>

<body>

  <div class="container">

    <h2>Upload a ZIP or HTML file for validation</h2>

    <!-- UPLOAD FORM -->
    <form id="uploadForm">
      <input type="file" id="fileInput" accept=".zip,.html" required /><br />
      <button type="submit" id="submitBtn">Upload &amp; Validate</button>
    </form>

    <!-- PREVIEW -->
    <div class="banner-preview" id="previewContainer"></div>

    <!-- RESULTS -->
    <h3>Validation Results:</h3>
    <div id="results"></div>

    <!-- EXPORT BUTTONS -->
    <button id="savePdfBtn"
            style="display:none; margin-top:10px; padding:8px 14px;">
      üíæ Save Results as PDF
    </button>

    <button id="saveWordBtn"
            style="display:none; margin-top:10px; padding:8px 14px;">
      üíæ Download Word Report
    </button>

  </div>

  <script>
    function formatFileSize(bytes) {
      if (bytes < 1024) return `${bytes} B`;
      if (bytes < 1024 * 1024) return `${Math.round(bytes / 1024)} KB`;
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    }

    let lastValidationData = null;
    let lastUploadedFileName = "";

    document.getElementById('uploadForm').addEventListener('submit', async function (event) {
      event.preventDefault();

      const fileInput = document.getElementById("fileInput");
      const submitBtn = document.getElementById("submitBtn");
      const resultsDiv = document.getElementById("results");
      const previewContainer = document.getElementById("previewContainer");
      const savePdfBtn = document.getElementById("savePdfBtn");
      const saveWordBtn = document.getElementById("saveWordBtn");

      if (fileInput.files.length === 0) {
        alert("Please select a file to upload.");
        return;
      }

      const uploadedFile = fileInput.files[0];
      lastUploadedFileName = uploadedFile.name;

      submitBtn.disabled = true;
      resultsDiv.innerHTML = "";
      resultsDiv.style.display = "block";
      previewContainer.innerHTML = "";
      savePdfBtn.style.display = "none";
      saveWordBtn.style.display = "none";

      const formData = new FormData();
      formData.append("file", uploadedFile);

      try {
        const response = await fetch("/validate", {
          method: "POST",
          body: formData
        });

        const data = await response.json();
        if (data.error) {
          resultsDiv.innerHTML = `<p class="error">‚ùå ${data.error}</p>`;
          submitBtn.disabled = false;
          return;
        }

        lastValidationData = data;

        const fileSizeFormatted = formatFileSize(uploadedFile.size);

        resultsDiv.innerHTML =
          `<p class="info">üì¶ File Selected: <strong>${uploadedFile.name}</strong> (${fileSizeFormatted})</p>`;

        if (data.file_size_kb !== undefined) {
          const maxLimit = 150;
          const overLimit = data.file_size_kb > maxLimit;
          const resultText = overLimit
            ? `(${data.file_size_kb} KB) Above 150 KB ‚Äì please confirm against spec (HTML5 vs Rich).`
            : ` File size within 150 KB (${data.file_size_kb} KB).`;
          const sizeClass = overLimit ? "check" : "pass";
          resultsDiv.innerHTML +=
            `<p class="${sizeClass}">üìè File Weight Check: ${resultText}</p>`;
        }

        if (data.validation_results) {
          const htmlResults = data.validation_results.html || {};
          const jsResults = data.validation_results.js || {};

          // Assets
          const hasMissingAssets = Object.values(htmlResults).some(
            r => (r.errors || []).some(e => e.includes("Missing assets"))
          );
          resultsDiv.innerHTML +=
            `<p class="${hasMissingAssets ? 'fail' : 'pass'}">üìÅ Assets Check: ` +
            `${hasMissingAssets ? "‚ùå Missing assets ‚Äì please review." : "‚úÖ All required assets found (no missing paths)."}</p>`;

          // Sizes
          const bannerSizes = Object.values(htmlResults)
            .map(r => r.banner_size)
            .filter(size => !!size);

          if (bannerSizes.length > 0) {
            const uniqueSizes = [...new Set(bannerSizes)];
            resultsDiv.innerHTML +=
              `<p class="info">üñº Banner Size(s): ${uniqueSizes.join(", ")}</p>`;
          }

          // HTML Validation summary
          const htmlCount = Object.keys(htmlResults).length;
          resultsDiv.innerHTML +=
            `<p class="${htmlCount > 0 ? 'pass' : 'fail'}">üìÑ HTML Validation: ` +
            `${htmlCount > 0 ? "‚úÖ HTML file(s) checked" : "‚ùå No HTML files detected"}</p>`;

          // HTML warnings
          Object.entries(htmlResults).forEach(([fileName, result]) => {
            if (result.warnings && result.warnings.length > 0) {
              result.warnings.forEach(warning => {
                resultsDiv.innerHTML +=
                  `<p class="warning">‚ö†Ô∏è [${fileName}] ${warning}</p>`;
              });
            }
            if (result.errors && result.errors.length > 0) {
              result.errors.forEach(err => {
                resultsDiv.innerHTML +=
                  `<p class="fail">‚ùå [${fileName}] ${err}</p>`;
              });
            }
          });

          // JS Loop count / errors
          const loopIssue = Object.values(jsResults)
            .flatMap(r => r.errors || [])
            .find(e => e.toLowerCase().includes("loop count exceeds"));

          resultsDiv.innerHTML +=
            `<p class="${loopIssue ? 'fail' : 'pass'}">üîÅ Loop Count: ` +
            `${loopIssue ? `‚ùå ${loopIssue}` : "‚úÖ Within recommended loop limit"}</p>`;

          // Border
          const firstHtml = Object.values(htmlResults)[0];
          if (firstHtml && firstHtml.border) {
            const borderPass = firstHtml.border.includes("‚úÖ");
            resultsDiv.innerHTML +=
              `<p class="${borderPass ? 'pass' : 'warning'}">üü¶ Border Check: ${firstHtml.border}</p>`;
          }

          // Click area summary
          const clickAreaWarning = Object.values(htmlResults)
            .flatMap(r => r.warnings || [])
            .find(w => w.includes("No clickable area"));

          if (clickAreaWarning) {
            resultsDiv.innerHTML +=
              `<p class="warning">‚ö†Ô∏è Clickable Area: ${clickAreaWarning}</p>`;
          } else {
            resultsDiv.innerHTML +=
              `<p class="pass">üñ±Ô∏è Clickable Area: A click layer or JS click handler is present or not flagged.</p>`;
          }
        }

        if (data.durations) {
          resultsDiv.innerHTML +=
            `<p class="info">üéØ Animation Duration: ${data.durations.animation}s</p>`;
          resultsDiv.innerHTML +=
            `<p class="info">üìú ISI Scroll Duration: ${data.durations.isi}s</p>`;
          resultsDiv.innerHTML +=
            `<p class="info">üßÆ Total Estimated Duration: ${data.durations.total}s</p>`;
        }

        /** üî• ENHANCED PREVIEW UI */
        if (data.previews && data.previews.length > 0) {
          previewContainer.innerHTML = "<h3>Banner Previews:</h3>";
          const grid = document.createElement("div");
          grid.className = "preview-grid";
          previewContainer.appendChild(grid);

          data.previews.forEach((previewUrl, index) => {
            const htmlEntries = Object.entries(data.validation_results.html || {});
            const resultEntry = htmlEntries[index];
            const correspondingHtmlResult = resultEntry ? resultEntry[1] : null;
            const sizeText = correspondingHtmlResult?.banner_size || "Unknown Size";

            const card = document.createElement("div");
            card.className = "preview-card";

            const label = document.createElement("p");
            label.className = "info";
            label.textContent = `üñº Banner Size: ${sizeText}`;
            card.appendChild(label);

            const frame = document.createElement("div");
            frame.className = "preview-frame";

            const iframe = document.createElement("iframe");
            iframe.src = previewUrl;

            let iframeWidth = 300;
            let iframeHeight = 250;

            if (sizeText.includes("x")) {
              const parts = sizeText.split("x");
              const w = parseInt(parts[0].trim(), 10);
              const h = parseInt(parts[1].trim(), 10);
              if (!Number.isNaN(w) && !Number.isNaN(h)) {
                iframeWidth = w;
                iframeHeight = h;
              }
            }

            let scale = 1;
            if (iframeWidth > 600) scale = 0.5;
            if (iframeWidth > 900) scale = 0.4;

            iframe.width = iframeWidth + "px";
            iframe.height = iframeHeight + "px";
            iframe.style.transform = `scale(${scale})`;
            iframe.style.transformOrigin = "top center";
            iframe.style.border = "1px solid #ccc";

            frame.appendChild(iframe);
            card.appendChild(frame);

            const openBtn = document.createElement("button");
            openBtn.className = "open-btn";
            openBtn.textContent = "Open in New Tab";
            openBtn.onclick = () => window.open(previewUrl, "_blank");
            card.appendChild(openBtn);

            const thumbToggle = document.createElement("button");
            thumbToggle.className = "open-btn";
            thumbToggle.style.background = "#666";
            thumbToggle.textContent = "Toggle Thumbnail";
            thumbToggle.onclick = () => {
              iframe.classList.toggle("thumbnail");
            };
            card.appendChild(thumbToggle);

            grid.appendChild(card);
          });
        }

        // show export buttons
        savePdfBtn.style.display = "inline-block";
        saveWordBtn.style.display = "inline-block";

      } catch (error) {
        console.error("Error:", error);
        resultsDiv.innerHTML = `<p class="error">‚ùå An error occurred while validating.</p>`;
      } finally {
        submitBtn.disabled = false;
      }
    });

    /** üî• PDF EXPORT */
    document.getElementById("savePdfBtn").addEventListener("click", async () => {
      const { jsPDF } = window.jspdf;

      const resultsDiv = document.getElementById("results");
      const previewGrid = document.getElementById("previewContainer");

      const combined = document.createElement("div");
      combined.style.padding = "20px";
      combined.style.background = "#fff";
      combined.style.width = "800px";

      combined.appendChild(resultsDiv.cloneNode(true));
      combined.appendChild(document.createElement("hr"));
      combined.appendChild(previewGrid.cloneNode(true));

      const canvas = await html2canvas(combined, { scale: 2 });

      const pdf = new jsPDF("p", "mm", "a4");
      const imgData = canvas.toDataURL("image/png");

      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const imgWidth = pageWidth;
      const imgHeight = (canvas.height * imgWidth) / canvas.width;

      let heightLeft = imgHeight;
      let position = 0;

      pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
      heightLeft -= pageHeight;

      while (heightLeft > 0) {
        pdf.addPage();
        position = heightLeft - imgHeight;
        pdf.addImage(imgData, "PNG", 0, position, imgWidth, imgHeight);
        heightLeft -= pageHeight;
      }

      pdf.save("ad_validation_report.pdf");
    });

    /** üìù WORD EXPORT */
    document.getElementById("saveWordBtn").addEventListener("click", async () => {
      if (!lastValidationData) {
        alert("Please validate a file first.");
        return;
      }

      try {
        const response = await fetch("/word-report", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            file_name: lastUploadedFileName,
            file_size_kb: lastValidationData.file_size_kb,
            validation_results: lastValidationData.validation_results,
            durations: lastValidationData.durations
          })
        });

        if (!response.ok) {
          alert("Error generating Word report.");
          return;
        }

        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        const baseName = lastUploadedFileName
          ? lastUploadedFileName.replace(/\.[^/.]+$/, "")
          : "ad_validation_report";
        a.download = baseName + ".docx";
        document.body.appendChild(a);
        a.click();
        a.remove();
        window.URL.revokeObjectURL(url);
      } catch (err) {
        console.error(err);
        alert("Error generating Word report.");
      }
    });
  </script>

</body>
</html>
